# 1. 이산수학

## 1.1. 이산수학이란

이산수학(Discrete mathematics, 離散數學)에서 이산이란 연속성이 없는 분리된 상태를 의미한다. 한마디로 붙어있지 않고 떨어진 값들을 다루는 학문이다. 이렇게 다루는 이유는 컴퓨터는 애초에 bit(0과 1)로 데이터를 처리하고 On/Off(1/0)의 전기신호로 연산을 하기 때문이다.

## 1.2. 이산수학에서 다루는 것들

- **연산**과 **수**
- 문제해결을 위한 **논리**와 **증명**
- 데이터 관리와 **집합**
- 자료 처리를 위한 **행렬**과 관계
- 명령 정의를 위한 **함수**
- 효과적 문제 해결과 자료 관리를 위한 **그래프**와 **트리**
- **회로 설계**와 부울 대수
- 결과 예측을 위한 **확률**
- 효율성을 위한 **알고리즘**

# 2. 수의 표현

## 2.1. 수체계
중고등학교에서 우리가 배웠던 것처럼 수는 형태에 따라 분류를 하고 이름을 붙이는 데 이를 수 체계라 한다.

### 2.1.1. 자연수
```
def : 0보다 큰! 양의 정수
```
기수와 자리수를 이용해 표현할 수 있는데 10진수 589는 `5 * 10^2 + 8 * 10^1 + 9 * 10^0` 이런식으로 전개해서 표현할 수 있다. 더 확장해서 일반식으로 만들어서 수체계의 각 형태를 표현하기도 한다.

### 2.1.2. 정수
```
def : 양의 정수, 0, 음의 정수
```

### 2.1.3. 유리수
```
def : 두 정수 a, b로 이루어진 분수 b/a (단 a != 0)
```

### 2.1.4. 무리수
```
def : 유리수로 표현할 수 없는 수
```

### 2.1.5. 실수
```
def : 자연수, 정수, 유리수, 무리수를 모두 포함하는 수 체계
```

### 2.1.6. 복소수
```
def : √-1, 즉 제곱하여 -1이 되는 가공의 수를 허수(i)라 하는데 이 허수와 실수를 포함하는 수체계
```
`c = a + bi` 형태로 표현되며 실수부(a)와 허수부(b)가 있다.

## 2.2. 수의 연산
수체계 S에 속하는 어떤 수 a,b를 연산자 O로 연산한 결과 c가 S에 속하면 "S는 연산 O에 닫혀 있다"고 표현한다. 즉 모든 자연수는 어떻게 덧셈을 해도 자연수 이므로 "자연수는 덧셈에 대해 닫혀 있다."고 말할 수 있다.

### 2.2.1. 사칙 연산에 대한 닫힘성질(기호 O가 닫혀있다는 뜻)
수|+|-|*|/|
-|-|-|-|-|
자연수 | O | X | O | X
정수 | O | O | O | O
유리수 | O | O | O | O
무리수 | X | X | X | X
실수 | O | O | O | O
복소수 | O | O | O | O

무리수의 경우
- 덧셈 : `-√3 + √3 = 0(유리수)`
- 뺄셈 : `√3 - √3 = 0(유리수)`
- 곱셈 : `(√3)^2 = 3(유리수)`
- 나눗셈 : `√3 / √3  = 1(유리수)`

모든 연산에 대해 유리수가 될 수 있는 반례가 있으므로 닫혀있지 않다.

### 2.2.2. 덧셈과 곱셈 연산 특징
1. 교환법칙 : x + y = y + x, xy = yx
2. 결합법칙 : (x + y) + z = x + (y + z), (xy)z = x(yz)
3. 분배법칙 : x(y + z) = xy + xz

### 2.2.3. 항등원과 역원
- **항등원**\
해당 연산자에 대해 어떤 수 a와 연산한 결과가 a가 되게 하는 수\
예를 들어 덧셈에서는 0이다.
- **역원**\
해당 연산자에 대해 어떤 수 a와 연산한 결과가 그 연산자의 항등원이 되게 하는 수\
예를 들어 덧셈에서는 역원이 -a이다.

```js
// 덧셈에 대한 항등원 : 0
a + 0 = a
// 덧셈에 대한 역원 : -a
a + (-a) = 0
// 곱에 대한 항등원 : 1
a * 1 = a
// 곱에 대한 역원 : (1/a)
a * (1/a) = 1
```

### 2.2.4. 시그마(Σ)
일정한 규칙이 있는 수열의 합을 시그마 기호를 사용하여 구한다. 예를들어 20이하의 홀수의 합은 다음과 같다.\
<sub>10</sub>\
Σ(2i - 1) = 1 + 3 + 5 ... + 17 + 19\
<sup>i=1</sup>

### 2.2.5. 프로덕트(∏)
일정한 규칙이 있는 수열의 곱은 프로덕트 기호를 사용하여 구한다.
<sub>10</sub>\
∏(2i - 1) = 1 * 3 * 5 ... * 17 * 19\
<sup>i=1</sup>

### 2.2.6. 팩토리얼(!)
```
n! = n * (n-1) * ... * 2 * 1
```
### 2.2.7. 몫과 나머지 연산자
몫(Quotient)연산자는 몫이 얼만지를 나타낸다.
```
5 | 20 = 4
```

나머니(Remainder)연산자는 나머지가 얼마인지를 계산한다.
```
20 mod 3 = 2
```


# 4. 증명
개발한 프로그램의 처리 속도, 효율성, 유지보수성 등 여러가지 검증자료를 정리하여 이전 버전보다 향상된 기능을 보여주어야 하는데 이러한 과정을 증명(Proof)이라고 한다?

증명은 어떠한 명제가 참 또는 거짓임을 밝히는 과정이기 때문에 전제로 사용되는 명제들은 반드시 참이어야 하고 그 전제들은 논리적이고 정확해야한다.

## 4.1. 증명의 이해 
### 4.1.1. 공리(Axiom)
```
def : 별도의 증명 없이 항상 참으로 이용되는 명제
```

공리는 이미 증명된 규칙이라고 보면된다. 이 공리로 부터 다른 모든 규칙들이 세워진다.

예시
- 서로 다른 두점을 잇는 직선은 하나다(비유클리드에서!).
- 어떤 자연수 n에 대해 n+1이 존재한다.

### 4.1.2. 정의(Definition)
```
def : 논의의 대상을 보편화하기 위해 사용하는 용어 또는 기호의 의미를 확실하게 규정한 문장이나 식
```

정의는 우리가 이걸 어떻게 부르겠다는 약속이다. 우리가 사용하는 단어들이 정의가 된 대표적인 예들이다.

예시
- 한 내각의 크기가 직각인 삼각형을 직각삼각형이라고 한다.


### 4.1.3. 정리(Theorem)
```
def : 공리와 정의를 통해 참으로 확인된 명제
```

예시
- 피타고라스의 정리 : 직각삼각형에서 빗변의 제곱은 밑변의 제곱과 높이의 제곱의 합니다.

### 4.1.4. 증명(Proof)
```
def : 하나의 명제가 참임을 확인하는 과정
```
증명을 하는 방법에는
- 직접증명법
- 간접증명법
- 존재증명법
- 수학적귀납법

등이 있다.

## 4.2. 직접증명법
```
def : 조건명제 p->q가 참임을 증명하기 위해 전제 p를 참으로 가정했을 때 결론 q도 참임을 증명하는 방법.
```

예시 : 두 홀수의 곱은 홀수임을 증명할 때
```
p : 두 정수 m,n은 홀수이다.
q : m,n의 곱은 홀수이다.

m = 2k+1, n = 2l+1 (k,l은 정수)

m과 n의 곱은 다음과 같다

m * n = (2k + 1)(2l + 1) = 4kl + 2k + 2l + 1 = 2(2kl + k + l) + 1

(2kl + k + l)은 어쨌든 정수이고(정수는 덧셈에 대해 닫혀있다) 정수에 2배를 하면 짝수인데 거기에 1을 더했으므로 두 홀수의 곱은 홀수이다.
```

## 4.3. 간접증명법
주어진 명제 p->q를 그대로 증명하기 어려울 때 p->q와 동칭틴 다른 형태의 명제로 전환하여 공리, 정의, 정리등을 활용해 증명할 수 있는데, 이러한 증명법을 간접증명법이라한다.

**즉, 명제 그대로 두고 증명하면 직접증명법! 명제를 좀 치환해서 증명하면 간접증명법!**

간접증명법에는 대우증명법과 모순증명법이 있다.

### 4.3.1. 대우증명법(Proof by Contrapositive)

대우명제는 본명제와 참거짓이 같다. 그렇기 때문에 대우명제가 참임을 증명하면 본명제도 참이다.
```
def : 조건명제 p->q와 그 대우 ~q->~p가 동치임을 이용하여 증명하는 방법
```
예시 : 두 정수 m,n의 곱이 홀수이면, m,n은 모두 홀수임을 증명하라
```
p : 두 정수 m,n의 곱이 홀수이다.
q : m, n은 모두 홀수이다.
~p : 두 정수 m,n의 곱은 짝수이다.
~q : 두 정수 m,n은 짝수이다.

~q -> ~p : 두정수 m,n이 짝수이면 그 곱도 짝수이다.

m = 2k, n = 2l
m * n = 4kl

a = 2kl이라 하면

m * n = 2a

따라서 명제는 참이다.
```

### 4.3.2. 모순증명법
조건명제 `p->q`는 `~(p AND ~q)`와 동치이다.
```
~(p AND ~q) === ~p OR ~(~q)
            === ~p OR q
            === p->q
```
이러한 성질을 이용해 명제 `p and ~q`를 증명하는 것이다. 즉 명제 p가 참인경우 명제 q를 부정하여 증명(~q)했을 때 명제 `p and ~q`가 거짓이 되면 본 명제 `p->q`는 참이되는 것이다.
```
def : 조건명제 p->q와 ~(p and ~q)가 동치임을 이용하여 p and ~q가 거짓임을 보여 증명하는 방법.
```
예시 : 두 홀수의 곱이 홀수가 됨을 증명

```
p : 두 정수 m, n 은 홀수이다.
q : m, n의 곱은 홀수이다.
~q : m, n의 곱은 짝수이다.
p and ~q : 두 정수 m, n은 홀수이고 m, n의 곱은 짝수이다.

m = 2k + 1, n = 2l + 1

m * n = (2k + 1)(2l + 1) = 2(2kl + k + l) + 1 이므로 m, n 의 곱은 홀수이다.

따라서 p and ~q 의 명제가 거짓이 되므로

~(p and ~q) 와 같은 p->q는 참이 된다.
```
## 4.4. 존재/반례 증명법

### 4.4.1. 존재증명법
