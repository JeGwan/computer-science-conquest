# 7. Input and Output

## 7.1. Standard Input and Output
문자 스트림은 여러 개의 행으로 구성되는데, 각 행의 끝에는 줄바꿈 문자가 있다. 라이브러리의 함수는 줄바꿈 또는 리턴키 등에 적절히 대응하는 동작을 해야 한다.

가장 간단한 입력방법은 보통의 키보드로 표준 입력의 `getchar`를 이용하여 한 번에 한 문자씩 읽어 들이는 것이다. `getchar`는 그것이 호출될 때마다 다음의 입력 문자를 넘겨주고 파일의 끝을 만나면 EOF라는 값을 넘겨준다. 이 값은 상수고 보통 -1의 값을 가지지만 환경에 따라 다르다.

대부분의 환경에서는 `<`를 이용하여 키보드 대신에 파일을 이용할 수 있게 한다. 예를 들어 prog라는 프로그램 내에서 getchar가 사용되었다면 infile이라는 파일로부터 문자를 읽어 들이게 하기 위해 다음과 같이 한다.

### 파일을 입력으로 받기
```bash
prog <infile
```
`<infile`은 argv 안에 있는 명령 라인 매개변수에 포함되지 않는다. 입력 전환은 만약 입력이 다른 프로그램으로부터 온다 해도 밖에서는 보이지 않는다.
### 다른 프로그램의 출력을 입력으로 받기
```bash
otherprog|prog
```
위와 같은 CLI 명령어는 otherprog와 prog라는 두 프로그램을 실행시키고 otherprog의 standard output을 prog의 standard input으로 되게 한다.

### 출력을 파일로 저장하기
`putchar`는 문자를 표준 출력인 스크린에 보낸다. 에러 발생 시에는 EOF를 리턴한다. 출력은 다음과 같은 방식으로 파일로 전환이 가능하다.
```bash
prog >outfile
```

입출력 라이브러리 함수를 사용하는 프로그램의 시작 부분에는 반드시 다음 행이 필요하다.
```c
#include <stdio.h>
```
이때 이름은 <>를 사용하여 묶는데 이것은 표준 지정장소에 `stdio.h` 파일이 있다는 뜻이다.

막간 괄호 표현 정리
- () parentheses
- {} curly bracket or brace
- [] square bracket or just bracket(US)
- <> pointy bracket or less than greater than

## 7.2. Formatted Output-Printf
출력함수 printf는 내부의 수치 값을 문자로 바꾸어 준다.
```c
int printf(char *format, arg1, arg2, ...)
```
printf는 format이라는 문자열을 출력할 때 매개변수를 변환하고 형식화한 다음 출력시키고 출력된 문자의 개수를 리턴한다. 출력형식 제어 문자열은 두 종류가 있는데, 하나는 출력될 보통의 문자이고(그냥 문자) 또 하나는 출력형식을 정해주는 컨버전 문자(책에서는 conversion specification)이다. 즉 변수의 자리임을 나타내는 syntax이다.

컨버전 문자의 앞에는 %를 붙인다. %와 컨버전 문자 사이에는 다음과 같은 것들이 올 수 있다.
- 변환된 매개변수를 왼쪽에 맞추어 출력하게 하는 `-` 부호
- 최소 너비를 지정하는 숫자. 변환된 매개변수는 적어도 이 너비로 출력된다. 길이보다 짧게 입력하면 왼쪽 또는 오른쪽의 폭을 맞추기 위해 공백 또는 0으로 채워진다.
- 유효숫자를 타나내는 마침표 `.`
- 정밀도를 나타내는 숫자.
    - 문자열의 경우 : 최대 길이를 의미
    - 실수형의 경우 : 소수점 이하 숫자 길이를 의미
    - 정수형의 경우 : 최소 숫자 길이를 의미
- 만일 정수가 short로 출력되어야 하면 `h`, long으로 출력시키려면 `l`을 쓴다.
### printf의 컨버전 문자들
컨버전 문자 | 출력 형태
-:|-
d, i| int 10진수
o | int 8진수
x, X | int 16진수
u | int 부호 없는 10진수
c | int 단일 문자
s | char* 문자열로부터 '\0'이 있을 때까지 문자가 출력되거나<br> 정밀도에 의해 주어진 문자수만큼만 출력된다.
f | double [-]m, dddddd 여기서 d는 정밀도에 따라 다르다.(기본은 6자리)
e, E | double [-]m, ddddd e±xx 또는 [-]m, ddddddE±xx, <br>여기서도 d는 정밀도에 따라.(기본 6자리)
g,G | double 만일 지수가 주어진 정밀도 보다 크거나 -4보다 작으면<br> %e or %E를 사용하고 그렇지 않다면 %f를 사용한다.<br> 뒤에 붙는 0과 소수점은 출력되지 않는다.
p | void* 포인터, 어떤형태의 포인터든 집어넣으면 주소가 출력되는데 <br>이는 시스템에 따라 다름.
% | 변환되지 않는다. 그냥 %출력.
정밀도는 *로도 표현할 수 있는데, 그러면 출력형태는 출력될 매개변수의 최대 길이만큼을 리턴한다.

이를테면 다음을 보자.
```
%-15.10s
// 이는 15개의 자리를 갖는 문자열을 10자리 까지 표현하며 왼쪽정렬(-)하라는 의미다
// 다음을 리턴한다. |는 경계를 표시한 것이다.
|hello, wor      |
```

주의할 것은 컨버전 문자가 나타내는 데이터 타입과 해당 매개변수의 데이터타입이 일치해야한다는 점이다.

## 7.3. Variable-length Argument Lists
가변 길이(variable-length)를 가진 parameter 를 portable하게 처리할 수 있는 함수를 minprintf를 만들어보자.
```c
#include <starg.h>

void minprintf(char *fmt, ...){
  va_list ap; 
  // 매개변수를 차례로 가리키는 포인터 변수, argument pointer의 약자로 지었다.
  char *p, *sval;
  int ival;
  double dval;
  va_start(ap, fmt);
  // va_start는 va_list에 첫번째 매개변수를 할당해주는 역할이다
  for(p = fmt; *p; p++){
    // 이것은 포맷문자열의 처음부터 한 글자식 보는 루프이다.
    // pointer와 array를 기억하자
    if(*p != '%'){
      putchar(*p);
      continue;
      // 컨버전 문자가 아니면 그대로 출력하고 컨티뉴한다.
    }
    switch(*++p){
      // %일 경우 다음 글자에 따라 switch
      case 'd':
        // 정수형이므로
        ival = va_arg(ap,int);
        // var_arg는 함수로 들어온 매개변수 하나를 리턴하고
        // ap가 다음 매개변수를 가리키게 리턴한다.
        // stdarg.h는 매개변수를 어레이 형태로 처리하고
        // 그럼 각 매개변수의 주소가 붙어 있을 것이며 때문에
        // 배열에서 포인터가 다음 원소를 접근하는 것처럼
        // 기존 ap에 ap가 가리키는 데이터타입의 공간 다음에
        // 다음 순서의 매개변수의 주소가 있을 것이다.
        // 때문에 뒤에 데이터타입을 넣어준 것이다.
        printf("%d",ival);
        break;
      case 'f':
        dval = va_arg(ap,dobule);
        printf("%f",dval);
        break;
      case 's':
        for(sval=va_arg(ap, char*); *sval; sval++){
          putchar(*sval);
        }
        break;
      default:
        putchar(*p);
        break;
    }
  }
  va_end(ap);
  // ap에 있는 것을 지운다.
} 
```
그냥 단순히 %s, %f, %d를 너비나 유효자리수 따위를 정하지 않고 받은 변수 그대로를 출력해주는 미니 함수이다.

## 7.4. Formatted Input-Scanf
함수 scanf는 printf와 사용법이 유사한 함수인데, 출력함수가 아니고 입력함수이다.
scanf는 표준 입력으로부터 문자를 읽어 들여서 format의 변환형식에 따라 그들을 해석하고 매개변수에 결과를 저장한다.

즉, 포맷문자열을 매개변수로 주고나서 입력을 하면, 해당 포맷에 맞게 해석한다.
포맷 문자열을 주지 않을 땐 보통의 매개변수는 입력되는 문자가 위치해야 하는 곳을 가리키는 포인터이다. 즉, 문자가 저장되는 변수의 포인터변수이다.

여기서 포맷문자열(컨버전문자열)은 다음을 포함한다.
- 공백 또는 탭 즉 화이트스페이스는 무시된다.
- %를 제외한 보통 문자들
- %컨버전 문자, 변환이 없음을 알리는 *, 최대 자리수를 표시하는 숫자, short/long을 정해주는 h, l, L

cf. 16진수는 영어로 hexadecimal이며 x는 이를 위한 약자이다.
### 기본 scanf 변환
컨버전문자 | 입력데이터 : 매개변수 타입
-:|-
d | 10진수 정수 : INT *
i | 정수 : INT *, 정수는 8진수(숫자앞에 O를 붙이면) 또는 <br>16진수(숫자앞에 Ox 또는 OX를 붙이면)가 될수도 있다.
o | 8진수 정수(앞에 O가 있거나 없는) : int *
u | 부호 없는 10진수 정수 : unsigned int *
x | 16진수 정수(앞에 Ox나 OX가 있거나 없는) : int *
c | 문자 : char *, white space의 뛰어넘기는 하지 않는다.<br> 다음의 non-white space 문자를 읽어 들이려면 %1s를 사용한다.
s | 문자열 : char *, 문자열을 위한 충분한 크기의 문자 배열을 가리킨다.<br> 문자열 끝에는 '\0'을 붙인다.
e, f, g | 부호, 10진포인터와 짓수를 선택적으로 가질 수 있는 부동소수점수 : float *
% | 문자 % : 매개변수로의 할당은 이어지지 않는다.

보통 결과는 대응되는 매개변수가 가리키는 변수에 저장되지만, 컨버전문자 *에 의해 입력되는 항목은 할당되지 않는다. 입력 필드는 non-white space문자의 문자열로 정의되고 다음의 white space문자까지 또는 필드 너비가 명시되었을 경우 필드 폭까지의 필드가 된다.

복잡하게 써있지만 다음의 예시를 그냥 보자.
```c
#include <stdio.h>

main(){
  double sum, v;
  sum = 0;
  while(scanf("%1f",&v) == 1)
    // 다음의 non-white space 문자 하나를 받고("%1s")
    // 그것을 call by value를 극복하기 위해 포인터 형태로 전달된(&v)
    // v에 저장한다. scanf의 리턴 값은 읽은 문자의 개수 이므로
    // EOF를 만나기 전까지 읽은 문자는 1글자씩 즉 위의 조건문을 만족하게되고
    // EOF를 만나면 EOF그대로를 리턴하기 때문에 while 문이 끝난다.
    printf("\t%.2f\n", sum+=v);
    // 읽어들인 숫자를 순서대로 합친 값을 출력했다.
  retun 0;
}
```

다음과 같은 형태의 날짜 데이터를 읽기 원한다면
```
25 Dec 1988
```
`scanf` 명령문은 다음과 같이 쓴다.
```c

```