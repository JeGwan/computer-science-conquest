### 5.1 Pointers and Addresses
포인터는 다른 변수의 주소를 그 값으로 가지는 변수이다. 또한 배열과 밀접한 관계를 가지고 있다.

`ANSI C`에서는 포인터 사용이 더 명확하게 되었고 일반적인 포인터 형태로 void*가 사용된다.

#### 포인터와 주소
보통 배열은 메모리에 연속적으로 기록되며 한 `byte`가 문자가 될 수도 있고(이 당시에는 `ASCII`를 썼고 `ASCII`는 `7bit`의 사이즈를 갖으므로 `8bit = byte`, 한바이트를 갖는 것이 맞다) 연속된 두개의 바이트가 `short integer`가 될 수도 있으며(이 역시 `short`타입은 `16bit`를 갖기 때문), 연속된 네개의 바이트가 `long integer`가 될 수도 있다. 포인터는 어떤 변수의 번지를 기억한다. 예를 들어 `c`가 `char`형이고 그 포인터가 `p`라고 할 때 `p`의 값은 **`c`가 기록되어 있는 메모리의 번지**가 된다.

요컨대 둘다 메모리에 기록된 값이며 변수이다. 다만 `p`의 값은 **`c`의 주소**라는 점이 포인터 변수의 핵심이다.

항목 |`c` | `p`
-----|----|-----
type | char | ?
value | 'a'(임의의 문자, 여기선 'a' 로 했다) | 25292
address | 25292 | 35154

이렇게 보면 더 확실하게 보인다. `p`는 **`c`의 주소**를 가지고 있는 메모리를 차지하는 변수라는 것이.

#### & operator (비트연산자가 아니다! 비트연산자 &은 두개의 operand를 받는다!)
포인터의 할당
```c
p = &c;
```
`&c`는 c의 주소를 리턴한다. 다시 말해 위식은 `p`라는 변수에 `c`의 주소를 값으로 담은 것이다.

당연하게도 메모리를 사용하지 않은 상수는(이를테면 123, '1') 포인터를 사용할 수 없고, 메모리를 차지하고 있는 변수와 배열에만 사용할 수 있다.

#### * operator
`*`연산자는 반대 역할을 한다. 즉 포인터 변수에 `*` 연산을 하면 그 포인터가 가리키고 있는 변수의 값을 가리킨다(때문에 `*p`는 사실상 `c`와 같다). 

```c
char c = 'a';
p = &c;

printf("%c",*p); 
```
이 문장에서 `*p`는 `'a'`를 나타낸다. 즉 `p`가 가지고 있는 값인 `c`의 주소로 가서 `c`가 가지고 있는 값인 `'a'`를 나타내는 것이다.

#### 포인터의 선언
```c
char *p;
```
제일 먼저 와야할 선언을 제일 뒤로 빼는 이유는 위의 개념들을 알고 와야 이 수식이 이상해보이지 않는다. 포인터는 `int p`의 형태로 선언되지 않는다. 오로지 `char(포인터로 가리키는 변수가 가진 데이터형) *p`의 형태로 선언된다.

#### void*
특별히 `void`타입이라는 것이 있는데 제약이 있지만 어떤 타입의 포인터도 될 수 있다.

#### *p 는 c이다
`*p`는 `c`대신 쓰일 수 있다. 즉
```c
int c = 1;
int *p;
p = &c;
*p = *p + 1;
```
에서 마지막줄은 `c = c + 1`과 같고 `c++`, `++c`와 같은 표현이다.

#### 포인터 역시 변수이다
포인터 역시 변수이기에 다른 변수에 할당이 가능하다.
```c
q = p;
```
이 식에서 q는 p가 가리켰던 c의 주소를 가리키게 된다.

다음식에서 이 것을 정리해보았다.
```c
#include <stdio.h>
int main(void) {
  int x =1 , y=2, z[10];
  int *ip;
  ip=&x; // get x address
  y=*ip; // equals to y=x; y assigned x's value, 1
  *ip=0; // equals to x=0; x assigned 0, now x == 0
  ip = &z[0]; // get z[0]'s address, now &ip == z[0]
  printf("x:%d, y:%d",x,y); // x:0, y:1
}
```
### 5.2 Pointers and Function Arguments
C에서는 호출할 때 arguments는 그 값만 전달되므로 (`call by value`) 호출된 함수에서 호출한 함수에 할당된 변수의 값을 바꾸는 것은 불가능하다. 예를들어
```c
swap(a,b);
```
에서 `swap`이라는 함수가 다음과 같다면
```c
void swap(int x, int y){
  int temp;
  temp = x;
  x = y;
  y = temp;
}
```
호출된 함수 `swap`은 스코프 내에서 값만을 전달 받아 지역변수 `x, y`에 할당하는 것이므로 호출한 함수가 있는 곳의 `x, y`에 영향을 주지 않는다.

원하는 결과를 얻으려면 다음과 같이 포인터를 사용하면 된다.

```c
swap(&a,&b);

void swap(int *px, int *py){
  int temp;

  temp = *px;
  *px = *py;
  *py = temp;
}
```
이것은 `&a,&b`를 통해 `a,b`의 주소를 포인터 `px, py`에 할당하고 아래의 식은 전에 언급한 것처럼 `temp = a; a = b; b = temp;`와 동치가 된다.

즉 `call by value`로 C언어에서 함수가 호출 되는 것은 어쩔 수 없기에 `value`에 `address`를 실어 보내 마치 전역변수처럼 다른 스코프에서 해당 변수를 조작할 수 있는 것이다.


### 5.3 Pointers and Arrays
C에서 포인터와 배열은 밀접한 관계가 있다. 배열에 의한 연산은 포인터를 사용해서 할 수 있으며, 포인터를 사용하는 것이 더 빠르기는 하지만 좀 더 어렵다.

길이가 10인 배열
```
int a[10];
```
을 선언했을 때, 우리는 `a[0],...,a[9]`까지의 변수를 사용할 수 있다. 배열은 변수를 한번에 쉽게 생성하고, 인덱스를 통해 수식적 접근을 가능하게 해준다.

배열과 포인터를 함께 쓰면 좋은 점은 **배열은 처음부터 끝까지 1씩 증가하는(바로 옆에 붙어있는) 주소를 가지기 때문이다.** 즉 `a[0]`의 메모리주소에 1만 더하면 `a[1]`의 메모리주소가 된다.

코드를 통해 보자.

```c
int a[10];
int *pa; // pointer of a
pa = &a[0]; // now *pa == a[0]
x = *pa; // equals to x = a[0], if a[0]'s value was 0, x has value 0
*(pa+1) == a[1]; // true
```
`pa`는 `a[0]`의 주소를 가지고 있었기 때문에 1만 더하면 `a[1]`의 주소를 가지게 되고 * 연산자를 쓰게 되면 `*pa`는 `a[1]`과 동치(equivalent)가 된다.

#### a는 a[0]의 주소를 가진 포인터!
배열로 선언된 변수 자체는 이름으로 쓸 때 첫번째 원소의 주소와 같기 때문에 다음 두 문장은 equivalent 하다.

```c
pa = a;
pa = &a[0];
```
즉 배열 자체를 expression으로 쓰면 첫번째 원소의 주소를 리턴한다는 말이다.

조금만 생각하면 `a[i]`는 `*(a+i)`와 같다. 단계별로 나누어 보자.
```c
a+i; // &a[0] + i == a[i]의 주소 == &a[i]
*(a+i) // *(&a[i]) == a[i]
```

`pa[i]`는 `*(pa + i)`와 같고 그냥 `a[i]`와 같다.

다시 말해 **배열과 인덱스의 표현은 포인터와 오프셋(한점으로 부터 떨어진 거리)으로 표현한 것과 equivalent하다!**

#### 배열의 이름 a는 포인터 "상수"이다!
위 코드에 `pa`는 변수이다 다시말해 `pa=a`나 `pa++`과 같은 표현을 쓸 수 있다.

하지만 배열의 이름은 변수가 아닌 **상수**이다. 때문에 `a=pa` 나 `a++`등의 표현은 사용할 수 없다.

이번엔 문자열을 넘겨받아 길이를 반환하는 함수를 보자.
문자열은 `char` 데이터 타입의 원소로 이루어진 배열이고, 문자열을 넘긴다는 것은 곳 배열을 넘긴다는 것이며, 배열을 넘긴다는 것은 곧 그 배열의 첫번째 원소의 주소를 넘긴다는 말임을 우리는 이제 안다. 따라서 함수의 매개변수는 `char`형을 값으로 갖는 **포인터**가 될것이며 길이를 리턴하므로 int를 함수명 앞에 써주어야 한다.

```c
int strlen(char *s){
  int n;
  for(n=0; *s != '\0'; s++)
    n++;
  return n;
}
```
조건 `*s != '\0'`은 **문자열이 끝나지 않는 동안** 이라는 뜻이다(모든 문자열은 마지막 인덱스에 `'\0'`으로 끝을 표시해주는 값을 갖는다).

위의 함수를 호출할 때에는 단순히
```c
char a[] = "abcde";
strlen(a);
```
와 같이 쓰면된다.

### 5.4 Address Arithmetic
C의 주소 연산(Address Arithmetic)은 아주 체계적이다. 포인터와 배열 그리고 주소 연산이 통합되어 있다는 것은 C의 큰 장점 중 하나이다.

단순한 기억장소할당 프로그램을 예로 들어보자. 이 프로그램에는 `alloc(n)`과 `afree(p)` 두 루틴이 필요하다. 구조는 두 루틴이 사용할 메모리공간 `allocbuf`, 그리고 사용하지 않은 메모리 주소를 가진 `allocp` 그리고 두 루틴 `alloc(n)`(할당하는 함수)과 `afree(p)`(해제하는 함수)로 이루어져 있다.

`alloc(n)`은 n이라는 문자열을 받고 `allocbuf`에 여유가 있는지를 조사해야한다. 있으면 할당한 문자열의 첫번째 메모리 주소(동시에 할당전 비어있는 첫번째 메모리)를 가진 포인터 `allocp`를 리턴하고 `allocp`를 n만큼 증가시킨다. 없으면 0을 리턴한다. 

`afree(p)`는 `p`가 `allocbuf` 내를 가리키면 `allocp`에 `p`의 값을 넣어준다(`p`이후로 버리므로 이제 `allocbuf`의 첫공간 주소는 `p`이기 때문).

함수로 보면 더 이해가 편한다. 다음을 보자

```c
#define ALLOCSIZE 10000

static char allocbuf[ALLOCSIZE]; //외부 함수에서 사용할 필요가 없으므로 static 선언.
static char *allocp = allocbuf; //allocbuf의 첫 공간 주소를 가진 포인터 allocp 선언.
// allocp = allocbuf 가 맞는 식이겠지만 포인터 선언식이기에 이렇게 쓰인 것이다.

char *alloc(int n){
  // 매개변수 데이터 타입이 int인 이유는 문자 char을 ascii코드 int로 처리할 수 있어서이다.
  if(allocbuf + ALLOCSIZE - allocp >= n){
    // 위의 식은 빈공간의 가장 처음 주소 allocp를 전체에서 빼준 값이 n보다 커야 
    // 자리가 있다는 뜻이므로 조건식으로 쓴 것이다.
    allocp += n;
    return allocp - n;
    // 여기서는 allocp를 리턴하고 더 할수가 없어서 더하고 다시 뺀 값을 리턴했다.
  }else{
    return 0;
  }
}

void afree(char *p){
  if(p>=allocbuf && p < alocbuff+ALLOCSIZE){
    // 위식은 'p가 allocbuf의 공간 내에 있으면' 이라는 조건이다.
    allocp = p;
  }
}
```

위의 코드에서 포인터의 몇가지 특징을 볼 수 있다.

**하나**, 포인터의 값으로 0을 사용할 수 있다. 포인터와 0을 비교할 수도 있다. 0 대신 NULL을 사용하기도 한다.

**둘**, 포인터 끼리 계산할 수 있다. 만약 `p`와 `q`가 같은 배열 내의 원소를 가리키는 포인터라면 비교연산자를 통한 비교, 차이 계산을 할 수 있다(한마디로 앞에 있냐, 뒤에 있냐, 오프셋은 얼마냐).

#### 주의 사항
1. 포인터에 대한 정수를 더하거나 뺄 수 있다.
2. 포인터를 0과 비교할 수도 있고 같은 배열 내의 두 포인터를 비교하거나 뺄 수도 있다.
3. 그러나 그 외는 모두 할 수 없는 연산이다.
#### 할수 없는 연산
1. 포인터 끼리 더하기, 곱하기, 나누기등을 할 수 없다.
2. 포인터에 float이나 double을 더하거나 빼서도 안된다.
3. 포인터를 곱셈, 나눗셈 해서도 안된다.
4. 포인터에 비트연산을 하면 안된다.
5. cast 연산자 없이 타입이 서로 다른 포인터를 하나에서 다른 하나로 할당할 수 없다.

#### 이것만 기억하자
**포인터끼리의 연산은 오로지 배열 내의 주소와 그 주소로부터의 오프셋을 위한 것**이다.

그렇게만 생각하면 할 수 있는 것과 없는 것이 구분된다.